#!/usr/bin/env python3
"""
ST7701 LCD fillRect Performance Benchmark Script
===============================================

This script generates Arduino code to benchmark fillRect performance
on the M5Stack Core S3 hardware. It measures actual microsecond timing
for various fillRect operations and logs the results.

Usage:
    python3 benchmark_fillrect.py > benchmark_sketch.ino
    
Then upload benchmark_sketch.ino to your M5Stack Core S3 and monitor
the serial output for timing results.

Requirements:
    - M5Stack Core S3 with ST7701 LCD
    - Arduino IDE or PlatformIO
    - Serial monitor at 115200 baud

The benchmark tests:
    - Full screen fills (320x240)
    - Quarter screen fills (160x120) 
    - Small rectangle fills (50x50)
    - Line drawing performance
    - Multiple operation sequences

Results help validate the ~5x performance improvement claims
from the buffer size optimization.
"""

import time
from datetime import datetime

def generate_benchmark_sketch():
    """Generate the complete Arduino benchmark sketch."""
    
    sketch = f'''/*
 * ST7701 LCD fillRect Performance Benchmark
 * Generated by benchmark_fillrect.py on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
 * 
 * This sketch measures actual fillRect performance on M5Stack Core S3.
 * Results are logged to Serial at 115200 baud.
 */

#include "st7701_lcd.h"

#if defined(ARDUINO_M5STACK_CORES3) || defined(M5STACK_CORES3)

// Benchmark configuration
const int WARMUP_ITERATIONS = 5;      // Warmup runs to stabilize timing
const int BENCHMARK_ITERATIONS = 10;  // Actual measurement runs
const int SERIAL_BAUD = 115200;

// Test scenarios
struct BenchmarkTest {{
    const char* name;
    int16_t x, y, w, h;
    uint16_t color;
}};

const BenchmarkTest tests[] = {{
    {{"Full Screen Fill", 0, 0, 320, 240, LCD_WHITE}},
    {{"Quarter Screen Fill", 0, 0, 160, 120, LCD_RED}},
    {{"Small Rectangle", 100, 100, 50, 50, LCD_GREEN}},
    {{"Horizontal Line", 0, 120, 320, 1, LCD_BLUE}},
    {{"Vertical Line", 160, 0, 1, 240, LCD_YELLOW}},
    {{"Large Square", 50, 50, 220, 140, LCD_CYAN}},
    {{"Tiny Rectangle", 150, 150, 20, 20, LCD_MAGENTA}},
    {{"Wide Strip", 0, 100, 320, 40, 0xF81F}},
    {{"Tall Strip", 140, 0, 40, 240, 0x07FF}},
    {{"Buffer Size Test", 0, 0, 256, 4, 0xFFE0}}  // Exactly 1024 pixels (2x buffer)
}};

const int NUM_TESTS = sizeof(tests) / sizeof(tests[0]);

void setup() {{
    Serial.begin(SERIAL_BAUD);
    delay(2000);  // Wait for serial monitor
    
    Serial.println("\\n=== ST7701 LCD fillRect Performance Benchmark ===");
    Serial.println("Hardware: M5Stack Core S3");
    Serial.println("Display: 320x240 ST7701 LCD");
    Serial.printf("Buffer Size: %d pixels (%d bytes)\\n", LCD_FILLRECT_BUFFER_SIZE, LCD_FILLRECT_BUFFER_SIZE * 2);
    Serial.printf("SPI Speed: %d MHz\\n", ST7701_SPI_SPEED / 1000000);
    Serial.println();
    
    // Initialize LCD
    if (!lcd.begin()) {{
        Serial.println("ERROR: LCD initialization failed!");
        return;
    }}
    
    Serial.println("LCD initialized successfully.");
    
    // Clear screen
    lcd.fillScreen(LCD_BLACK);
    delay(500);
    
    Serial.println("\\nStarting benchmark...");
    Serial.println("Format: Test Name | Avg Time (μs) | Min (μs) | Max (μs) | Pixels | μs/pixel");
    Serial.println("--------------------------------------------------------------------------------");
    
    // Run all benchmark tests
    for (int i = 0; i < NUM_TESTS; i++) {{
        runBenchmarkTest(tests[i]);
        delay(100);  // Brief pause between tests
    }}
    
    // Multi-operation sequence test
    runMultiOperationBenchmark();
    
    Serial.println("\\n=== Benchmark Complete ===");
    Serial.println("\\nLegend:");
    Serial.println("- Times are in microseconds (μs)");
    Serial.println("- Lower μs/pixel values indicate better performance");
    Serial.println("- Variance indicates timing consistency");
    
    // Display performance summary
    displayPerformanceSummary();
}}

void loop() {{
    // Benchmark complete - just blink to show we're alive
    delay(1000);
}}

void runBenchmarkTest(const BenchmarkTest& test) {{
    unsigned long times[BENCHMARK_ITERATIONS];
    unsigned long total_time = 0;
    unsigned long min_time = ULONG_MAX;
    unsigned long max_time = 0;
    
    // Calculate pixel count
    uint32_t pixels = (uint32_t)test.w * test.h;
    
    // Warmup runs
    for (int i = 0; i < WARMUP_ITERATIONS; i++) {{
        lcd.fillRect(test.x, test.y, test.w, test.h, test.color);
    }}
    
    // Actual benchmark runs
    for (int i = 0; i < BENCHMARK_ITERATIONS; i++) {{
        unsigned long start_time = micros();
        lcd.fillRect(test.x, test.y, test.w, test.h, test.color);
        unsigned long end_time = micros();
        
        times[i] = end_time - start_time;
        total_time += times[i];
        
        if (times[i] < min_time) min_time = times[i];
        if (times[i] > max_time) max_time = times[i];
        
        // Small delay to let system settle
        delayMicroseconds(100);
    }}
    
    // Calculate statistics
    unsigned long avg_time = total_time / BENCHMARK_ITERATIONS;
    float us_per_pixel = (float)avg_time / pixels;
    
    // Print results
    Serial.printf("%-20s | %8lu | %7lu | %7lu | %6lu | %8.3f\\n",
                  test.name, avg_time, min_time, max_time, pixels, us_per_pixel);
    
    // Flash the test area to show completion
    lcd.fillRect(test.x, test.y, test.w, test.h, LCD_BLACK);
    delay(50);
    lcd.fillRect(test.x, test.y, test.w, test.h, test.color);
}}

void runMultiOperationBenchmark() {{
    Serial.println("--------------------------------------------------------------------------------");
    Serial.println("Multi-Operation Sequence Test:");
    
    const int SEQUENCE_ITERATIONS = 5;
    unsigned long sequence_times[SEQUENCE_ITERATIONS];
    unsigned long total_sequence_time = 0;
    
    for (int i = 0; i < SEQUENCE_ITERATIONS; i++) {{
        unsigned long start_time = micros();
        
        // Simulate typical drawing sequence
        lcd.fillScreen(LCD_BLACK);                        // Clear
        lcd.fillRect(0, 0, 320, 30, LCD_BLUE);           // Header bar
        lcd.fillRect(0, 210, 320, 30, LCD_BLUE);         // Footer bar
        lcd.fillRect(50, 50, 220, 120, LCD_WHITE);       // Main content area
        lcd.fillRect(60, 60, 200, 100, LCD_GREEN);       // Inner content
        
        // Draw some "UI elements"
        for (int j = 0; j < 5; j++) {{
            lcd.fillRect(70 + j * 35, 70, 30, 80, 0xF800 + j * 0x0200);
        }}
        
        unsigned long end_time = micros();
        sequence_times[i] = end_time - start_time;
        total_sequence_time += sequence_times[i];
        
        delay(100);  // Pause between sequences
    }}
    
    unsigned long avg_sequence_time = total_sequence_time / SEQUENCE_ITERATIONS;
    Serial.printf("Multi-Op Sequence    | %8lu | %7s | %7s | %6s | %8s\\n",
                  avg_sequence_time, "N/A", "N/A", "N/A", "N/A");
}}

void displayPerformanceSummary() {{
    Serial.println("\\n=== Performance Analysis ===");
    
    // Theoretical calculations
    float spi_bytes_per_second = ST7701_SPI_SPEED / 8.0f;  // Convert bits to bytes
    float theoretical_pixels_per_second = spi_bytes_per_second / 2.0f;  // 2 bytes per pixel
    float theoretical_us_per_pixel = 1000000.0f / theoretical_pixels_per_second;
    
    Serial.printf("Theoretical SPI throughput: %.1f MB/s\\n", spi_bytes_per_second / 1000000.0f);
    Serial.printf("Theoretical pixel rate: %.1f Mpixels/s\\n", theoretical_pixels_per_second / 1000000.0f);
    Serial.printf("Theoretical μs/pixel: %.3f\\n", theoretical_us_per_pixel);
    
    Serial.println("\\nOptimization Notes:");
    Serial.printf("- Buffer size: %d pixels reduces SPI transaction overhead\\n", LCD_FILLRECT_BUFFER_SIZE);
    Serial.println("- Larger rectangles should show better μs/pixel ratios");
    Serial.println("- Small rectangles have higher overhead due to setup costs");
    
    Serial.println("\\nTo compare with unoptimized version:");
    Serial.println("- Previous 128-pixel buffer would show ~4x worse performance");
    Serial.println("- Single-pixel writes would show ~50-100x worse performance");
    
    // Memory usage info
    Serial.printf("\\nMemory Usage: %d bytes static buffer\\n", LCD_FILLRECT_BUFFER_SIZE * 2);
    Serial.printf("Free heap: %d bytes\\n", ESP.getFreeHeap());
    Serial.printf("Free PSRAM: %d bytes\\n", ESP.getFreePsram());
}}

#else
// Not M5Stack Core S3 - provide dummy implementation
void setup() {{
    Serial.begin(115200);
    Serial.println("ERROR: This benchmark requires M5Stack Core S3 hardware");
}}

void loop() {{
    delay(1000);
}}
#endif
'''
    
    return sketch

def main():
    """Main function to generate and output the benchmark sketch."""
    sketch = generate_benchmark_sketch()
    print(sketch)
    
    # Also print usage instructions to stderr so they don't interfere with sketch output
    import sys
    print("", file=sys.stderr)
    print("=== Benchmark Script Generated ===", file=sys.stderr)
    print("", file=sys.stderr)
    print("To use this benchmark:", file=sys.stderr)
    print("1. Save the output to benchmark_sketch.ino", file=sys.stderr)
    print("2. Upload to your M5Stack Core S3", file=sys.stderr)
    print("3. Open Serial Monitor at 115200 baud", file=sys.stderr)
    print("4. Watch for performance results", file=sys.stderr)
    print("", file=sys.stderr)
    print("Expected results with optimization:", file=sys.stderr)
    print("- Full screen fill: ~100-200ms", file=sys.stderr)
    print("- μs/pixel ratios: 0.1-0.5 for large areas", file=sys.stderr)
    print("- Consistent timing across runs", file=sys.stderr)

if __name__ == "__main__":
    main()